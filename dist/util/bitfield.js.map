{"version":3,"file":"bitfield.js","sourceRoot":"/","sources":["util/bitfield.ts"],"names":[],"mappings":"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","sourcesContent":["export type BitFieldResolvable = string | bigint | BitField | Array<BitFieldResolvable>;\n\n/** Data structure that makes it easy to interact with a bitfield. */\nexport default class BitField {\n  /** Bitfield of the packed bits. */\n  bitfield = 0n;\n\n  /** The flags for this bitfield. */\n  static FLAGS: { [perm: string]: bigint } = {};\n\n  /** @param bits Bit(s) to read from. */\n  constructor(bits: BitFieldResolvable = 0n) {\n    // @ts-ignore\n    this.bitfield = this.constructor.resolve(bits);\n  }\n\n  /** @private */\n  get defaultBit() {\n    return 0n;\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param bit Bit(s) to check for\n   */\n  any(bit: BitFieldResolvable): boolean {\n    // @ts-ignore\n    return (this.bitfield & this.constructor.resolve(bit)) !== this.defaultBit;\n  }\n\n  /**\n   * Checks if this bitfield equals another.\n   * @param bit Bit(s) to check for\n   */\n  equals(bit: BitFieldResolvable): boolean {\n    // @ts-ignore\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param bit Bit(s) to check for\n   */\n  has(bit: BitFieldResolvable): boolean {\n    if (Array.isArray(bit)) return bit.every((p) => this.has(p));\n    // @ts-ignore\n    bit = this.constructor.resolve(bit);\n    // @ts-ignore\n    return (this.bitfield & bit) === bit;\n  }\n\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param bits Bit(s) to check for\n   */\n  missing(bits: BitFieldResolvable): string[] {\n    // @ts-ignore\n    const bitsArray: string[] = new this.constructor(bits).toArray();\n    return bitsArray.filter((p) => !this.has(p));\n  }\n\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   */\n  serialize(): { [key: string]: boolean } {\n    const serialized: { [key: string]: boolean } = {};\n    // @ts-ignore\n    for (const [flag, bit] of Object.entries(this.constructor.FLAGS)) serialized[flag] = this.has(bit as BitFieldResolvable);\n    return serialized;\n  }\n\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   */\n  toArray(): string[] {\n    // @ts-ignore\n    return Object.keys(this.constructor.FLAGS).filter((bit) => this.has(bit));\n  }\n\n  /** @hidden */\n  toString() {\n    return `[${this.constructor.name} ${this.bitfield}]`;\n  }\n\n  /** @hidden */\n  toJSON() {\n    return this.bitfield.toString();\n  }\n\n  /** @hidden */\n  valueOf() {\n    return this.bitfield;\n  }\n\n  /** @hidden */\n  *[Symbol.iterator]() {\n    yield* this.toArray();\n  }\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param bit Bit(s) to resolve\n   */\n  static resolve(bit?: BitFieldResolvable): bigint {\n    if (typeof bit === 'undefined') return 0n;\n    if (typeof bit === 'bigint' && bit >= 0n) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map((p) => this.resolve(p)).reduce((prev, p) => prev | p, 0n);\n    if (typeof bit === 'string' && typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];\n    throw new RangeError('BITFIELD_INVALID');\n  }\n}\n"]}