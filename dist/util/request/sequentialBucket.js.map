{"version":3,"file":"sequentialBucket.js","sourceRoot":"/","sources":["util/request/sequentialBucket.ts"],"names":[],"mappings":";;AAAA,0CAAqE;AAgBrE,MAAqB,gBAAgB;IAsBnC,YAAY,KAAa,EAAE,KAAa,EAAE,aAAgC,EAAE,OAAO,EAAE,CAAC,EAAE;QAhBxF,eAAU,GAAG,KAAK,CAAC;QAInB,UAAK,GAAG,CAAC,CAAC;QAGF,WAAM,GAAuB,EAAE,CAAC;QAUtC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QACpC,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;IAED,IAAI,QAAQ;QACV,OAAO,UAAU,IAAI,CAAC,KAAK,EAAE,CAAC;IAChC,CAAC;IAED,KAAK,CAAC,SAAS,CAAC,EAAE,SAAS,EAAE,KAAK,KAA6C,EAAE;QAC/E,MAAM,IAAI,GAAU,EAAE,CAAC;QAEvB,IAAI,SAAS,KAAK,SAAS,EAAE;YAC3B,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YACvC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;SAC5B;QAED,IAAI,KAAK,KAAK,SAAS,EAAE;YACvB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;YAC/B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;SACpB;QAED,IAAI,iBAAc,EAAE;YAClB,MAAM,cAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,IAAI,CAAC,CAAC;YAC1C,IAAI,KAAK,KAAK,SAAS,EAAE;gBACvB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBACvB,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC;gBACvE,MAAM,cAAM,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,GAAG,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC;aAC7D;SACF;IACH,CAAC;IAED,KAAK,CAAC,iBAAiB;QACrB,IAAI,iBAAc,EAAE;YAClB,IAAI,CAAC,SAAS,GAAG,MAAM,cAAM,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,EAAE,CAAC,CAAC,CAAC,CAAC;SACvE;;YAAM,EAAE,IAAI,CAAC,SAAS,CAAC;IAC1B,CAAC;IAED,KAAK,CAAC,IAAI;QACR,IAAI,iBAAc,EAAE;YAClB,MAAM,CAAC,SAAS,EAAE,KAAK,CAAC,GAAG,MAAM,cAAM,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;YACnF,IAAI,SAAS;gBAAE,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;YACxD,IAAI,KAAK;gBAAE,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;SAC7C;IACH,CAAC;IAMD,KAAK,CAAC,KAAK,CAAC,QAAQ,GAAG,KAAK;QAC1B,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YAC5B,IAAI,IAAI,CAAC,UAAU,EAAE;gBACnB,YAAY,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;gBACrC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;aACzB;YACD,OAAO;SACR;QACD,IAAI,IAAI,CAAC,UAAU,IAAI,CAAC,QAAQ,EAAE;YAChC,OAAO;SACR;QACD,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;QAClB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC;QACvE,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,GAAG,GAAG,GAAG,MAAM,EAAE;YAE5C,IAAI,CAAC,KAAK,GAAG,GAAG,GAAG,MAAM,CAAC;YAC1B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC;SAC7B;QACD,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;QAChB,IAAI,IAAI,CAAC,SAAS,IAAI,CAAC,EAAE;YACvB,IAAI,CAAC,iBAAiB,GAAG,UAAU,CAAC,GAAG,EAAE;gBACvC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;gBACxB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACnB,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;YACtD,OAAO;SACR;QACD,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC/B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,MAAM,CAAC,KAAK,EAAuB,CAAC,GAAG,EAAE;YAC7C,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC1B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;aAClB;iBAAM;gBACL,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;aACzB;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAMD,KAAK,CAAC,IAAsB,EAAE,KAAK,GAAG,KAAK;QACzC,IAAI,KAAK,EAAE;YACT,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SAC3B;aAAM;YACL,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACxB;QACD,IAAI,CAAC,KAAK,EAAE,CAAC;IACf,CAAC;IAED,QAAQ;QACN,OAAO,oBAAoB,CAAC;IAC9B,CAAC;CACF;AA/HD,mCA+HC","sourcesContent":["import { available as redisAvailable, client } from '../../db/redis';\n\n/** @hidden */\nexport interface MinimalLatencyRef {\n  /** Interval between consuming tokens. */\n  latency: number;\n  offset?: number;\n}\n\n/** @hidden */\ntype CallbackFunction = (callback: () => void) => unknown;\n\n/**\n * Ratelimit requests and release in sequence.\n * @private\n */\nexport default class SequentialBucket {\n  /** The route the bucket is for. */\n  route: string;\n  /** How many tokens the bucket can consume in the current interval. */\n  limit: number;\n  /** Whether the queue is being processed. */\n  processing = false;\n  /** How many tokens the bucket has left in the current interval. */\n  remaining: number;\n  /** Timestamp of next reset. */\n  reset = 0;\n\n  private latencyRef: MinimalLatencyRef;\n  private _queue: CallbackFunction[] = [];\n  private processingTimeout: any;\n  private last?: number;\n\n  /**\n   * @param route The route this bucket is for\n   * @param limit The max number of tokens the bucket can consume per interval\n   * @param latencyRef The latency reference\n   */\n  constructor(route: string, limit: number, latencyRef: MinimalLatencyRef = { latency: 0 }) {\n    this.route = route;\n    this.limit = this.remaining = limit;\n    this.latencyRef = latencyRef;\n  }\n\n  get redisKey() {\n    return `bucket:${this.route}`;\n  }\n\n  async setValues({ remaining, reset }: { remaining?: number; reset?: number } = {}) {\n    const args: any[] = [];\n\n    if (remaining !== undefined) {\n      args.push('remaining', this.remaining);\n      this.remaining = remaining;\n    }\n\n    if (reset !== undefined) {\n      args.push('reset', this.reset);\n      this.reset = reset;\n    }\n\n    if (redisAvailable) {\n      await client.hset(this.redisKey, ...args);\n      if (reset !== undefined) {\n        const now = Date.now();\n        const offset = this.latencyRef.latency + (this.latencyRef.offset || 0);\n        await client.pexpire(this.redisKey, reset - (now - offset));\n      }\n    }\n  }\n\n  async decreaseRemaining() {\n    if (redisAvailable) {\n      this.remaining = await client.hincrby(this.redisKey, 'remaining', -1);\n    } else --this.remaining;\n  }\n\n  async sync() {\n    if (redisAvailable) {\n      const [remaining, reset] = await client.hmget(this.redisKey, 'remaining', 'reset');\n      if (remaining) this.remaining = parseInt(remaining, 10);\n      if (reset) this.reset = parseInt(reset, 10);\n    }\n  }\n\n  /**\n   * Checks the bucket and runs through the functions.\n   * @param override Whether to override the processing property\n   */\n  async check(override = false) {\n    if (this._queue.length === 0) {\n      if (this.processing) {\n        clearTimeout(this.processingTimeout);\n        this.processing = false;\n      }\n      return;\n    }\n    if (this.processing && !override) {\n      return;\n    }\n    await this.sync();\n    const now = Date.now();\n    const offset = this.latencyRef.latency + (this.latencyRef.offset || 0);\n    if (!this.reset || this.reset < now - offset) {\n      // When the bucket expires, leave the redis to expire as well\n      this.reset = now - offset;\n      this.remaining = this.limit;\n    }\n    this.last = now;\n    if (this.remaining <= 0) {\n      this.processingTimeout = setTimeout(() => {\n        this.processing = false;\n        this.check(true);\n      }, Math.max(0, (this.reset || 0) - now + offset) + 1);\n      return;\n    }\n    await this.decreaseRemaining();\n    this.processing = true;\n    (this._queue.shift() as CallbackFunction)(() => {\n      if (this._queue.length > 0) {\n        this.check(true);\n      } else {\n        this.processing = false;\n      }\n    });\n  }\n\n  /**\n   * Queue something in the SequentialBucket\n   * @param func A function to call when a token can be consumed. The function will be passed a callback argument, which must be called to allow the bucket to continue to work\n   */\n  queue(func: CallbackFunction, short = false) {\n    if (short) {\n      this._queue.unshift(func);\n    } else {\n      this._queue.push(func);\n    }\n    this.check();\n  }\n\n  toString() {\n    return '[SequentialBucket]';\n  }\n}\n"]}